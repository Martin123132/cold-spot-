import numpy as np
import matplotlib.pyplot as plt

# 🛠️ Bell-shaped curvature field
def generate_bell_universe(grid_size=512, height=1.0, steepness=3.0, cold_lat=-70.0, cold_lon=180.0):
    lat = np.linspace(-90, 90, grid_size)
    lon = np.linspace(-180, 180, grid_size)
    Lon, Lat = np.meshgrid(lon, lat)

    # Convert to radians
    lat_rad = np.radians(Lat)
    lon_rad = np.radians(Lon)
    cold_lat_rad = np.radians(cold_lat)
    cold_lon_rad = np.radians(cold_lon)

    # Radial distance from cold spot
    r = np.sqrt((lat_rad - cold_lat_rad)**2 + (lon_rad - cold_lon_rad)**2) + 1e-5

    # Bell-shaped curvature: time compression at base
    curvature = height / (1 + steepness * r**2)
    curvature /= np.max(curvature)

    return curvature, Lat, Lon

# 🎨 Plot curvature field
def plot_bell_universe(curvature, Lat, Lon, tag="Bell Universe Curvature"):
    plt.figure(figsize=(10, 5))
    cf = plt.contourf(Lon, Lat, curvature, levels=50, cmap='coolwarm')
    plt.colorbar(cf, label='Normalized Time Compression')
    plt.title(tag)
    plt.xlabel("Longitude (°)")
    plt.ylabel("Latitude (°)")
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

# 🚀 Run simulation
curv, Lat, Lon = generate_bell_universe()
plot_bell_universe(curv, Lat, Lon)


import numpy as np
import matplotlib.pyplot as plt

# Create a synthetic CMB cold spot field
def generate_cmb_cold_spot(grid_size=256, cold_center=(-57, 209), depth=1.0, spread=500):
    lat = np.linspace(-90, 90, grid_size)
    lon = np.linspace(0, 360, grid_size)
    Lon, Lat = np.meshgrid(lon, lat)
    r = (Lat - cold_center[0])**2 + (Lon - cold_center[1])**2
    cmb_field = -depth * np.exp(-r / spread)
    return cmb_field, Lat, Lon

# Create a synthetic MBT curvature field with a bell root
def generate_mbt_curvature(grid_size=256, root_center=(-70, 180), height=1.0, steepness=300):
    lat = np.linspace(-90, 90, grid_size)
    lon = np.linspace(0, 360, grid_size)
    Lon, Lat = np.meshgrid(lon, lat)
    r = (Lat - root_center[0])**2 + (Lon - root_center[1])**2
    curvature_field = height / (1 + steepness * r / 10000)
    return curvature_field, Lat, Lon

# Generate fields
cmb, Lat, Lon = generate_cmb_cold_spot()
mbt, _, _ = generate_mbt_curvature()

# Plot side-by-side
plt.figure(figsize=(10, 4))

plt.subplot(1, 2, 1)
plt.contourf(Lon, Lat, cmb, levels=50, cmap='coolwarm')
plt.title("Synthetic CMB Cold Spot")
plt.xlabel("Longitude (°)")
plt.ylabel("Latitude (°)")
plt.grid(True)

plt.subplot(1, 2, 2)
plt.contourf(Lon, Lat, mbt, levels=50, cmap='plasma')
plt.title("MBT Bell Curvature Field")
plt.xlabel("Longitude (°)")
plt.ylabel("Latitude (°)")
plt.grid(True)

plt.tight_layout()
plt.show()


import numpy as np
from astropy.coordinates import SkyCoord
import astropy.units as u
import matplotlib.pyplot as plt

# CMB cold spot galactic coordinates
cmb_l, cmb_b = 209, -56
cmb_coord = SkyCoord(l=cmb_l*u.deg, b=cmb_b*u.deg, frame='galactic')

# Generate N random MBT bell centers across the sky
N = 10000
rand_l = np.random.uniform(0, 360, N)
rand_b = np.random.uniform(-90, 90, N)
mbt_coords = SkyCoord(l=rand_l*u.deg, b=rand_b*u.deg, frame='galactic')

# Compute angular separations
separations = mbt_coords.separation(cmb_coord).deg

# Plot histogram of separations
plt.figure(figsize=(8, 5))
plt.hist(separations, bins=50, color='skyblue', edgecolor='black')
plt.axvline(32, color='red', linestyle='--', label='Observed MBT-CMB Separation (~32°)')
plt.xlabel("Angular Separation from CMB Cold Spot (°)")
plt.ylabel("Number of Random MBT Roots")
plt.title("Random MBT Bell Root Alignment Test")
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Print probability of getting ≤32° separation
hits = np.sum(separations <= 32)
prob = hits / N
print(f"Fraction of MBT roots within 32° of CMB cold spot: {prob:.4f} ({hits} out of {N})")


import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import pearsonr

# Parameters
grid_size = 256
cmb_center = (-57, 209)    # Latitude, Longitude of cold spot
mbt_center = (-70, 180)    # MBT curvature root
max_radius = 50            # degrees
num_rings = 10

# Generate synthetic fields
def generate_gaussian_field(center, amplitude, spread):
    lat = np.linspace(-90, 90, grid_size)
    lon = np.linspace(0, 360, grid_size)
    Lon, Lat = np.meshgrid(lon, lat)
    r2 = (Lat - center[0])**2 + (Lon - center[1])**2
    field = amplitude * np.exp(-r2 / spread)
    return field, Lat, Lon

cmb_field, Lat, Lon = generate_gaussian_field(cmb_center, amplitude=-1.0, spread=500)
mbt_field, _, _ = generate_gaussian_field(mbt_center, amplitude=1.0, spread=300)

# Compute radial ring profiles
ring_edges = np.linspace(0, max_radius, num_rings + 1)
cmb_profile = []
mbt_profile = []

for i in range(num_rings):
    r_min, r_max = ring_edges[i], ring_edges[i + 1]
    r2_cmb = (Lat - cmb_center[0])**2 + (Lon - cmb_center[1])**2
    r2_mbt = (Lat - mbt_center[0])**2 + (Lon - mbt_center[1])**2
    mask_cmb = (r2_cmb >= r_min**2) & (r2_cmb < r_max**2)
    mask_mbt = (r2_mbt >= r_min**2) & (r2_mbt < r_max**2)
    cmb_profile.append(np.mean(cmb_field[mask_cmb]))
    mbt_profile.append(np.mean(mbt_field[mask_mbt]))

# Compute correlation
corr, _ = pearsonr(cmb_profile, mbt_profile)

# Plot profiles
plt.figure(figsize=(8, 5))
r_centers = 0.5 * (ring_edges[:-1] + ring_edges[1:])
plt.plot(r_centers, cmb_profile, label='CMB Temperature', color='blue')
plt.plot(r_centers, mbt_profile, label='MBT Curvature', color='orange')
plt.xlabel("Radial Distance from Center (°)")
plt.ylabel("Mean Field Value")
plt.title(f"Ring Profile Comparison (Pearson r = {corr:.2f})")
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()



import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import pearsonr

# Parameters
grid_size = 256
cmb_center = (-57, 209)  # Latitude, Longitude
mbt_center = (-70, 180)  # Original MBT root
max_radius = 50
num_rings = 10
num_trials = 10000

# Generate MBT curvature field
def generate_mbt_field(center, amplitude=1.0, spread=300):
    lat = np.linspace(-90, 90, grid_size)
    lon = np.linspace(0, 360, grid_size)
    Lon, Lat = np.meshgrid(lon, lat)
    r2 = (Lat - center[0])**2 + (Lon - center[1])**2
    field = amplitude / (1 + spread * r2 / 10000)
    return field

# Compute ring profile
def compute_ring_profile(field, center):
    lat = np.linspace(-90, 90, grid_size)
    lon = np.linspace(0, 360, grid_size)
    Lon, Lat = np.meshgrid(lon, lat)
    ring_edges = np.linspace(0, max_radius, num_rings + 1)
    profile = []
    for i in range(num_rings):
        r_min, r_max = ring_edges[i], ring_edges[i + 1]
        r2 = (Lat - center[0])**2 + (Lon - center[1])**2
        mask = (r2 >= r_min**2) & (r2 < r_max**2)
        profile.append(np.mean(field[mask]))
    return profile

# Generate reference CMB profile (synthetic)
cmb_field = generate_mbt_field(cmb_center, amplitude=-1.0, spread=500)
cmb_profile = compute_ring_profile(cmb_field, cmb_center)

# Run randomized MBT rotations
correlations = []
for _ in range(num_trials):
    rand_lat = np.random.uniform(-90, 90)
    rand_lon = np.random.uniform(0, 360)
    mbt_field = generate_mbt_field((rand_lat, rand_lon))
    mbt_profile = compute_ring_profile(mbt_field, cmb_center)
    r, _ = pearsonr(cmb_profile, mbt_profile)
    correlations.append(r)

# Plot histogram
plt.figure(figsize=(8, 5))
plt.hist(correlations, bins=50, color='lightgreen', edgecolor='black')
plt.axvline(-0.98, color='red', linestyle='--', label='Observed MBT-CMB Correlation (−0.98)')
plt.xlabel("Pearson Correlation Coefficient")
plt.ylabel("Number of Random Rotations")
plt.title("MBT Field Rotation: Correlation Distribution")
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Print tail probability
extreme_hits = np.sum(np.array(correlations) <= -0.98)
p_value = extreme_hits / num_trials
print(f"Fraction of MBT rotations with r ≤ −0.98: {p_value:.4f} ({extreme_hits} out of {num_trials})")



import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import pearsonr

# Load SMICA CMB map
cmb_map = hp.read_map("COM_CMB_IQU-smica_2048_R3.00_oe2.fits")
nside = hp.get_nside(cmb_map)
npix = hp.nside2npix(nside)

# Coordinates of a known hot spot (approx): l = 220°, b = -30°
theta_hot = np.radians(90 + 30)  # colatitude
phi_hot = np.radians(220)

# Parameters
num_rings = 10
max_radius_deg = 50
num_trials = 1000

# Ring profile extractor
def ring_profile(field, theta, phi, nside, npix):
    vec = hp.ang2vec(theta, phi)
    vecs = np.array(hp.pix2vec(nside, np.arange(npix)))
    dots = vecs[0]*vec[0] + vecs[1]*vec[1] + vecs[2]*vec[2]
    dots = np.clip(dots, -1.0, 1.0)
    angs_deg = np.degrees(np.arccos(dots))

    edges = np.linspace(0, max_radius_deg, num_rings + 1)
    profile = []
    for i in range(num_rings):
        mask = (angs_deg >= edges[i]) & (angs_deg < edges[i+1])
        profile.append(np.mean(field[mask]))
    return profile

# Extract CMB texture profile around hot spot
cmb_profile = ring_profile(cmb_map, theta_hot, phi_hot, nside, npix)

# MBT curvature shell rooted at hot spot
vec_hot = hp.ang2vec(theta_hot, phi_hot)
mbt_field_hot = np.zeros(npix)
mbt_field_hot[hp.query_disc(nside, vec_hot, np.radians(10.0))] = 1.0
mbt_profile_hot = ring_profile(mbt_field_hot, theta_hot, phi_hot, nside, npix)

# Reference correlation
ref_corr, _ = pearsonr(cmb_profile, mbt_profile_hot)

# Monte Carlo comparison
correlations = []
for _ in range(num_trials):
    rand_theta = np.radians(np.random.uniform(0, 180))
    rand_phi = np.radians(np.random.uniform(0, 360))
    vec_rand = hp.ang2vec(rand_theta, rand_phi)

    mbt_field_rand = np.zeros(npix)
    mbt_field_rand[hp.query_disc(nside, vec_rand, np.radians(10.0))] = 1.0
    mbt_profile_rand = ring_profile(mbt_field_rand, theta_hot, phi_hot, nside, npix)

    r, _ = pearsonr(cmb_profile, mbt_profile_rand)
    correlations.append(r)

# Histogram
plt.figure(figsize=(8, 5))
plt.hist(correlations, bins=50, color='salmon', edgecolor='black')
plt.axvline(ref_corr, color='blue', linestyle='--', label=f'MBT Alignment (r = {ref_corr:.2f})')
plt.xlabel("Pearson Correlation")
plt.ylabel("Number of Random MBT Fields")
plt.title("MBT–Hot Spot Texture Correlation")
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Significance output
extreme_hits = np.sum(np.array(correlations) >= ref_corr)
p_value = extreme_hits / num_trials
print(f"MBT–Hot Spot correlation: {ref_corr:.4f}")
print(f"Fraction of rotations with r ≥ {ref_corr:.2f}: {p_value:.4f} ({extreme_hits} out of {num_trials})")


import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import pearsonr

# Load CMB map (uploaded FITS file)
cmb_map = hp.read_map("COM_CMB_IQU-smica_2048_R3.00_oe2.fits")
nside = hp.get_nside(cmb_map)
npix = hp.nside2npix(nside)

# CMB cold spot coordinates (l = 209°, b = -56°)
theta_cmb = np.radians(90 + 56)
phi_cmb = np.radians(209)

# Parameters
num_rings = 10
max_radius_deg = 50
num_trials = 1000

# Ring profile extraction
def ring_profile(field, theta, phi, nside, npix):
    vec = hp.ang2vec(theta, phi)
    vecs = np.array(hp.pix2vec(nside, np.arange(npix)))
    dots = vecs[0]*vec[0] + vecs[1]*vec[1] + vecs[2]*vec[2]
    dots = np.clip(dots, -1.0, 1.0)
    angs_deg = np.degrees(np.arccos(dots))
    
    edges = np.linspace(0, max_radius_deg, num_rings + 1)
    profile = []
    for i in range(num_rings):
        mask = (angs_deg >= edges[i]) & (angs_deg < edges[i+1])
        profile.append(np.mean(field[mask]))
    return profile

# Reference CMB texture profile
cmb_profile = ring_profile(cmb_map, theta_cmb, phi_cmb, nside, npix)

# Monte Carlo MBT curvature rotations
correlations = []
for _ in range(num_trials):
    rand_theta = np.radians(np.random.uniform(0, 180))
    rand_phi = np.radians(np.random.uniform(0, 360))
    vec = hp.ang2vec(rand_theta, rand_phi)
    
    mbt_field = np.zeros(npix)
    mbt_field[hp.query_disc(nside, vec, np.radians(10.0))] = 1.0
    mbt_profile = ring_profile(mbt_field, theta_cmb, phi_cmb, nside, npix)
    
    r, _ = pearsonr(cmb_profile, mbt_profile)
    correlations.append(r)

# Plot histogram
plt.figure(figsize=(8, 5))
plt.hist(correlations, bins=50, color='mediumslateblue', edgecolor='black')
plt.axvline(-0.98, color='red', linestyle='--', label='Your Original Correlation (–0.98)')
plt.xlabel("Pearson Correlation")
plt.ylabel("Number of Random MBT Fields")
plt.title("MBT–SMICA Ring Profile Correlation (Monte Carlo)")
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Tail stat
extreme_hits = np.sum(np.array(correlations) <= -0.98)
p_value = extreme_hits / num_trials
print(f"Fraction of MBT rotations with r ≤ −0.98: {p_value:.4f} ({extreme_hits} out of {num_trials})")


import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import pearsonr

# Load Q/U polarization maps from SMICA FITS file
# Index 1 = Q, Index 2 = U
q_map = hp.read_map("COM_CMB_IQU-smica_2048_R3.00_oe2.fits", field=1)
u_map = hp.read_map("COM_CMB_IQU-smica_2048_R3.00_oe2.fits", field=2)

nside = hp.get_nside(q_map)
npix = hp.nside2npix(nside)

# Define coordinate (e.g., cold spot)
theta_cmb = np.radians(90 - 57)
phi_cmb = np.radians(207)

# Ring profile function
def ring_profile(field, theta, phi, nside, npix, num_rings=10, max_radius_deg=50):
    vec = hp.ang2vec(theta, phi)
    vecs = np.array(hp.pix2vec(nside, np.arange(npix)))
    dots = np.sum(vecs * np.array(vec)[:, None], axis=0)
    dots = np.clip(dots, -1.0, 1.0)
    angs_deg = np.degrees(np.arccos(dots))

    edges = np.linspace(0, max_radius_deg, num_rings + 1)
    profile = []
    for i in range(num_rings):
        mask = (angs_deg >= edges[i]) & (angs_deg < edges[i+1])
        profile.append(np.mean(field[mask]))
    return profile

# Extract polarization profiles
q_profile = ring_profile(q_map, theta_cmb, phi_cmb, nside, npix)
u_profile = ring_profile(u_map, theta_cmb, phi_cmb, nside, npix)

# MBT curvature shell at the same spot
vec_root = hp.ang2vec(theta_cmb, phi_cmb)
mbt_field = np.zeros(npix)
mbt_field[hp.query_disc(nside, vec_root, np.radians(10.0))] = 1.0
mbt_profile_q = ring_profile(mbt_field, theta_cmb, phi_cmb, nside, npix)
mbt_profile_u = ring_profile(mbt_field, theta_cmb, phi_cmb, nside, npix)

# Correlation
corr_q, _ = pearsonr(q_profile, mbt_profile_q)
corr_u, _ = pearsonr(u_profile, mbt_profile_u)

# Plot
plt.figure(figsize=(10, 5))
plt.subplot(1,2,1)
plt.plot(q_profile, label='Polarization Q')
plt.plot(mbt_profile_q, label='MBT Field')
plt.title(f"Q Profile Correlation: r = {corr_q:.2f}")
plt.grid(True); plt.legend()

plt.subplot(1,2,2)
plt.plot(u_profile, label='Polarization U')
plt.plot(mbt_profile_u, label='MBT Field')
plt.title(f"U Profile Correlation: r = {corr_u:.2f}")
plt.grid(True); plt.legend()
plt.tight_layout()
plt.show()


import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import pearsonr

# --- Load polarization maps ---
q_map = hp.read_map("COM_CMB_IQU-smica_2048_R3.00_oe2.fits", field=1)  # Q (E-mode)
u_map = hp.read_map("COM_CMB_IQU-smica_2048_R3.00_oe2.fits", field=2)  # U (B-mode)

nside = hp.get_nside(q_map)
npix = hp.nside2npix(nside)

# --- Cold spot dispatch root ---
theta_ref = np.radians(90 - 57)
phi_ref = np.radians(207)
vec_ref = hp.ang2vec(theta_ref, phi_ref)

# --- Ring profile extractor ---
def ring_profile(field, vec_center, num_rings=10, max_radius_deg=50):
    vecs = np.array(hp.pix2vec(nside, np.arange(npix)))
    dots = np.dot(vec_center, vecs)
    dots = np.clip(dots, -1.0, 1.0)
    angs_deg = np.degrees(np.arccos(dots))

    edges = np.linspace(0, max_radius_deg, num_rings + 1)
    profile = []
    for i in range(num_rings):
        mask = (angs_deg >= edges[i]) & (angs_deg < edges[i+1])
        profile.append(np.mean(field[mask]) if np.any(mask) else 0.0)
    return profile

# --- Reference Q/U ring profiles ---
q_profile_ref = ring_profile(q_map, vec_ref)
u_profile_ref = ring_profile(u_map, vec_ref)

# --- Curvature-weighted MBT shell ---
vecs = np.array(hp.pix2vec(nside, np.arange(npix)))
dots = np.dot(vec_ref, vecs)
dots = np.clip(dots, -1.0, 1.0)
angs_rad = np.arccos(dots)

height = 1.0
steepness = 3.0
curvature_values = height / (1 + steepness * angs_rad**2)
curvature_values /= np.max(curvature_values)
mbt_field = curvature_values

mbt_profile_ref = ring_profile(mbt_field, vec_ref)

# --- Reference correlations ---
corr_q_ref, _ = pearsonr(q_profile_ref, mbt_profile_ref)
corr_u_ref, _ = pearsonr(u_profile_ref, mbt_profile_ref)

print(f"🔍 MBT–Q Correlation: {corr_q_ref:.4f}")
print(f"🔍 MBT–U Correlation: {corr_u_ref:.4f}")

# --- Monte Carlo trials ---
num_trials = 1000
correlations_q, correlations_u = [], []

print("⚙️ Running randomized MBT shell trials...")
for i in range(num_trials):
    theta_rand = np.radians(np.random.uniform(0, 180))
    phi_rand = np.radians(np.random.uniform(0, 360))
    vec_rand = hp.ang2vec(theta_rand, phi_rand)

    dots_rand = np.dot(vec_rand, vecs)
    dots_rand = np.clip(dots_rand, -1.0, 1.0)
    angs_rand = np.arccos(dots_rand)

    mbt_rand = height / (1 + steepness * angs_rand**2)
    mbt_rand /= np.max(mbt_rand)

    mbt_profile_rand = ring_profile(mbt_rand, vec_ref)

    if np.std(mbt_profile_rand) == 0:
        continue

    r_q, _ = pearsonr(q_profile_ref, mbt_profile_rand)
    r_u, _ = pearsonr(u_profile_ref, mbt_profile_rand)
    correlations_q.append(r_q)
    correlations_u.append(r_u)

    if i % 50 == 0:
        print(f"Trial {i}/{num_trials}…")

# --- Histograms ---
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.hist(correlations_q, bins=50, color='deepskyblue', edgecolor='black')
plt.axvline(corr_q_ref, color='red', linestyle='--', label=f'MBT Q (r = {corr_q_ref:.2f})')
plt.title("Q Polarization Tail Correlation")
plt.xlabel("Pearson r"); plt.ylabel("Trials")
plt.grid(True, alpha=0.3); plt.legend()

plt.subplot(1, 2, 2)
plt.hist(correlations_u, bins=50, color='slategray', edgecolor='black')
plt.axvline(corr_u_ref, color='red', linestyle='--', label=f'MBT U (r = {corr_u_ref:.2f})')
plt.title("U Polarization Tail Correlation")
plt.xlabel("Pearson r"); plt.ylabel("Trials")
plt.grid(True, alpha=0.3); plt.legend()

plt.tight_layout()
plt.show()

# --- Tail stats ---
tail_q = sum(r <= corr_q_ref for r in correlations_q)
tail_u = sum(r <= corr_u_ref for r in correlations_u)

print(f"\n📈 MBT–Q tail hits: {tail_q}/{len(correlations_q)} → p = {tail_q / len(correlations_q):.4f}")
print(f"📈 MBT–U tail hits: {tail_u}/{len(correlations_u)} → p = {tail_u / len(correlations_u):.4f}")
















